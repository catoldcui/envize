import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import { ProfileStore } from '../../src/core/ProfileStore.js';
import { DotenvBridge } from '../../src/core/DotenvBridge.js';

describe('DotenvBridge', () => {
  let tempDir: string;
  let globalDir: string;
  let localDir: string;
  let store: ProfileStore;
  let bridge: DotenvBridge;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'envize-test-'));
    globalDir = path.join(tempDir, 'global', 'profiles');
    localDir = path.join(tempDir, 'local', 'profiles');
    fs.mkdirSync(globalDir, { recursive: true });
    fs.mkdirSync(localDir, { recursive: true });
    
    store = new ProfileStore(globalDir, localDir);
    bridge = new DotenvBridge(store);
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  describe('import', () => {
    it('should import .env file as profile', () => {
      const envPath = path.join(tempDir, '.env.staging');
      fs.writeFileSync(envPath, 'KEY1=value1\nKEY2=value2');

      const result = bridge.import(envPath, 'staging');

      expect(result.variableCount).toBe(2);
      expect(fs.existsSync(result.path)).toBe(true);
      
      const profile = store.loadProfile('staging');
      expect(profile?.variables.KEY1).toBe('value1');
    });

    it('should add default description', () => {
      const envPath = path.join(tempDir, 'test.env');
      fs.writeFileSync(envPath, 'KEY=value');

      bridge.import(envPath, 'test');

      const profile = store.loadProfile('test');
      expect(profile?.metadata.description).toContain('Imported from');
    });

    it('should use provided description and tags', () => {
      const envPath = path.join(tempDir, 'test.env');
      fs.writeFileSync(envPath, 'KEY=value');

      bridge.import(envPath, 'test', {
        description: 'Custom description',
        tags: ['custom', 'test'],
      });

      const profile = store.loadProfile('test');
      expect(profile?.metadata.description).toBe('Custom description');
      expect(profile?.metadata.tags).toEqual(['custom', 'test']);
    });

    it('should preserve existing metadata from .env file', () => {
      const envPath = path.join(tempDir, 'test.env');
      fs.writeFileSync(envPath, '# @description: Existing desc\n# @tags: existing\nKEY=value');

      bridge.import(envPath, 'test');

      const profile = store.loadProfile('test');
      expect(profile?.metadata.description).toBe('Existing desc');
      expect(profile?.metadata.tags).toContain('existing');
    });

    it('should throw for non-existent file', () => {
      expect(() => bridge.import('/nonexistent/path', 'test'))
        .toThrow('File not found');
    });
  });

  describe('export', () => {
    it('should export variables as .env content', () => {
      const variables = {
        KEY1: { value: 'value1', source: 'profile1' },
        KEY2: { value: 'value2', source: 'profile1' },
      };

      const content = bridge.export(variables);

      expect(content).toContain('KEY1=value1');
      expect(content).toContain('KEY2=value2');
      expect(content).toContain('Generated by envize');
    });

    it('should mask sensitive values by default', () => {
      const variables = {
        API_KEY: { value: 'supersecretkey123', source: 'profile1' },
      };

      const content = bridge.export(variables);

      expect(content).not.toContain('supersecretkey123');
      expect(content).toContain('****');
    });

    it('should reveal values with reveal option', () => {
      const variables = {
        API_KEY: { value: 'supersecretkey123', source: 'profile1' },
      };

      const content = bridge.export(variables, { reveal: true });

      expect(content).toContain('supersecretkey123');
    });

    it('should write to file with outputPath option', () => {
      const outputPath = path.join(tempDir, 'output.env');
      const variables = {
        KEY: { value: 'value', source: 'profile1' },
      };

      bridge.export(variables, { outputPath });

      expect(fs.existsSync(outputPath)).toBe(true);
      const content = fs.readFileSync(outputPath, 'utf-8');
      expect(content).toContain('KEY=value');
    });

    it('should group variables by source', () => {
      const variables = {
        KEY1: { value: 'v1', source: 'profile1' },
        KEY2: { value: 'v2', source: 'profile2' },
      };

      const content = bridge.export(variables, { reveal: true });

      expect(content).toContain('# From profile: profile1');
      expect(content).toContain('# From profile: profile2');
    });
  });

  describe('exportProfiles', () => {
    it('should export specific profiles', () => {
      fs.writeFileSync(path.join(globalDir, 'p1.env'), 'KEY1=value1');
      fs.writeFileSync(path.join(globalDir, 'p2.env'), 'KEY2=value2');

      const content = bridge.exportProfiles(['p1', 'p2'], { reveal: true });

      expect(content).toContain('KEY1=value1');
      expect(content).toContain('KEY2=value2');
    });

    it('should throw for non-existent profile', () => {
      expect(() => bridge.exportProfiles(['nonexistent']))
        .toThrow('Profile not found: nonexistent');
    });
  });
});
