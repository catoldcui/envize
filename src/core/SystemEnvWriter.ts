import type { ShellType } from '../types.js';
import { getActiveShPath, ensureDir, writeFile, deleteFile, fileExists, readFile } from '../utils.js';
import { ShellAdapter } from './ShellAdapter.js';
import * as path from 'node:path';

/**
 * SystemEnvWriter - writes/clears ~/.envize/active.sh for --global mode
 */
export class SystemEnvWriter {
  private activeShPath: string;
  private shellAdapter: ShellAdapter;

  constructor(activeShPath?: string, shell?: ShellType) {
    this.activeShPath = activeShPath ?? getActiveShPath();
    this.shellAdapter = new ShellAdapter(shell);
  }

  /**
   * Get the path to the active shell file
   */
  getPath(): string {
    return this.activeShPath;
  }

  /**
   * Write environment variables to the global file
   */
  write(variables: Record<string, string>): void {
    ensureDir(path.dirname(this.activeShPath));

    const lines: string[] = [
      '# Generated by envize - do not edit manually',
      `# Updated: ${new Date().toISOString()}`,
      '',
    ];

    // Generate export commands
    for (const [key, value] of Object.entries(variables)) {
      lines.push(this.shellAdapter.generateExport(key, value));
    }

    writeFile(this.activeShPath, lines.join('\n') + '\n');
  }

  /**
   * Clear the global file (for reset --global)
   */
  clear(): void {
    if (fileExists(this.activeShPath)) {
      deleteFile(this.activeShPath);
    }
  }

  /**
   * Check if the global file exists
   */
  exists(): boolean {
    return fileExists(this.activeShPath);
  }

  /**
   * Read the current global variables
   */
  read(): Record<string, string> {
    if (!this.exists()) {
      return {};
    }

    const content = readFile(this.activeShPath);
    const variables: Record<string, string> = {};

    for (const line of content.split('\n')) {
      const trimmed = line.trim();
      
      // Skip comments and empty lines
      if (!trimmed || trimmed.startsWith('#')) {
        continue;
      }

      // Parse export KEY='value' or set -gx KEY 'value'
      let match = trimmed.match(/^export\s+(\w+)='(.*)'\s*$/);
      if (match) {
        // Unescape single quotes
        variables[match[1]] = match[2].replace(/'\\''/g, "'");
        continue;
      }

      // Fish format
      match = trimmed.match(/^set\s+-gx\s+(\w+)\s+'(.*)'\s*$/);
      if (match) {
        variables[match[1]] = match[2].replace(/'\\''/g, "'");
      }
    }

    return variables;
  }

  /**
   * Update specific variables in the global file
   * Preserves existing variables not in the update
   */
  update(
    toSet: Record<string, string>,
    toUnset: string[]
  ): void {
    const current = this.read();

    // Remove unset variables
    for (const key of toUnset) {
      delete current[key];
    }

    // Add/update variables
    for (const [key, value] of Object.entries(toSet)) {
      current[key] = value;
    }

    // Write back
    if (Object.keys(current).length === 0) {
      this.clear();
    } else {
      this.write(current);
    }
  }
}
