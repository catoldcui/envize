import * as path from 'node:path';
import type { EnvVariable, ProfileMetadata } from '../types.js';
import { fileExists, readFile, writeFile } from '../utils.js';
import { ProfileStore } from './ProfileStore.js';

/**
 * DotenvBridge - import .env files as profiles, export active state as .env
 */
export class DotenvBridge {
  private profileStore: ProfileStore;

  constructor(profileStore: ProfileStore) {
    this.profileStore = profileStore;
  }

  /**
   * Import a .env file as a new profile
   */
  import(
    envFilePath: string,
    profileName: string,
    options: {
      local?: boolean;
      description?: string;
      tags?: string[];
    } = {}
  ): { path: string; variableCount: number } {
    if (!fileExists(envFilePath)) {
      throw new Error(`File not found: ${envFilePath}`);
    }

    const content = readFile(envFilePath);
    const variables = this.profileStore.parseVariables(content);
    const existingMetadata = this.profileStore.parseMetadata(content);

    // Use provided metadata or existing or defaults
    const metadata: ProfileMetadata = {
      description: options.description || existingMetadata.description || `Imported from ${path.basename(envFilePath)}`,
      tags: options.tags ?? (existingMetadata.tags.length > 0 ? existingMetadata.tags : []),
    };

    // Generate profile content with metadata
    const profileContent = this.profileStore.generateProfileContent(metadata, variables);
    const local = options.local ?? true;
    const profilePath = this.profileStore.saveProfile(profileName, profileContent, local);

    return {
      path: profilePath,
      variableCount: Object.keys(variables).length,
    };
  }

  /**
   * Export active state as a .env file
   */
  export(
    variables: Record<string, EnvVariable>,
    options: {
      reveal?: boolean;
      outputPath?: string;
    } = {}
  ): string {
    const lines: string[] = [
      '# Generated by envize',
      `# Generated at: ${new Date().toISOString()}`,
      '',
    ];

    // Group variables by source for readability
    const bySource: Map<string, Array<{ key: string; value: string }>> = new Map();
    
    for (const [key, envVar] of Object.entries(variables)) {
      const source = envVar.source;
      if (!bySource.has(source)) {
        bySource.set(source, []);
      }
      bySource.get(source)!.push({ key, value: envVar.value });
    }

    // Output variables grouped by source
    for (const [source, vars] of bySource) {
      lines.push(`# From profile: ${source}`);
      for (const { key, value } of vars) {
        const outputValue = options.reveal ? value : this.maskSensitiveValue(key, value);
        lines.push(`${key}=${this.quoteIfNeeded(outputValue)}`);
      }
      lines.push('');
    }

    const content = lines.join('\n');

    if (options.outputPath) {
      writeFile(options.outputPath, content);
    }

    return content;
  }

  /**
   * Export specific profiles as a .env file (without activating them)
   */
  exportProfiles(
    profileNames: string[],
    options: {
      reveal?: boolean;
      outputPath?: string;
    } = {}
  ): string {
    const lines: string[] = [
      '# Generated by envize',
      `# Profiles: ${profileNames.join(', ')}`,
      `# Generated at: ${new Date().toISOString()}`,
      '',
    ];

    // Load and merge profiles
    for (const name of profileNames) {
      const profile = this.profileStore.loadProfile(name);
      if (!profile) {
        throw new Error(`Profile not found: ${name}`);
      }

      lines.push(`# From profile: ${name}`);
      for (const [key, value] of Object.entries(profile.variables)) {
        const outputValue = options.reveal ? value : this.maskSensitiveValue(key, value);
        lines.push(`${key}=${this.quoteIfNeeded(outputValue)}`);
      }
      lines.push('');
    }

    const content = lines.join('\n');

    if (options.outputPath) {
      writeFile(options.outputPath, content);
    }

    return content;
  }

  /**
   * Mask sensitive values (API keys, secrets, etc.)
   */
  private maskSensitiveValue(key: string, value: string): string {
    const sensitivePatterns = [
      /key/i,
      /secret/i,
      /password/i,
      /token/i,
      /credential/i,
    ];

    const isSensitive = sensitivePatterns.some(pattern => pattern.test(key));
    
    if (isSensitive && value.length > 8) {
      return value.slice(0, 4) + '****' + value.slice(-4);
    }

    return value;
  }

  /**
   * Quote value if it contains special characters
   */
  private quoteIfNeeded(value: string): string {
    if (value.includes(' ') || value.includes('"') || value.includes("'") || value.includes('\n')) {
      // Use double quotes and escape existing double quotes
      return `"${value.replace(/"/g, '\\"')}"`;
    }
    return value;
  }
}
